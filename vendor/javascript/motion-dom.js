// motion-dom@12.23.23 downloaded from https://ga.jspm.io/npm:motion-dom@12.23.23/dist/es/index.mjs

import{MotionGlobalConfig as t,noop as e,clamp as n,warning as s,pipe as i,millisecondsToSeconds as r,velocityPerSecond as o,secondsToMilliseconds as a,invariant as c,progress as u,easeInOut as l,isEasingArray as h,easingDefinitionToFunction as d,memo as f,isBezierDefinition as m,circInOut as p,backInOut as g,anticipate as y,isNumericalString as v,isZeroValueString as w,isObject as b,warnOnce as T,SubscriptionManager as A,removeItem as x}from"motion-utils";const M=["setup","read","resolveKeyframes","preUpdate","update","preRender","render","postRender"];const k={value:null,addProjectionMetrics:null};function S(t,e){let n=new Set;let s=new Set;let i=false;let r=false;const o=new WeakSet;let a={delta:0,timestamp:0,isProcessing:false};let c=0;function u(e){if(o.has(e)){l.schedule(e);t()}c++;e(a)}const l={schedule:(t,e=false,r=false)=>{const a=r&&i;const c=a?n:s;e&&o.add(t);c.has(t)||c.add(t);return t},cancel:t=>{s.delete(t);o.delete(t)},process:t=>{a=t;if(i)r=true;else{i=true;[n,s]=[s,n];n.forEach(u);e&&k.value&&k.value.frameloop[e].push(c);c=0;n.clear();i=false;if(r){r=false;l.process(t)}}}};return l}const E=40;function P(e,n){let s=false;let i=true;const r={delta:0,timestamp:0,isProcessing:false};const o=()=>s=true;const a=M.reduce(((t,e)=>{t[e]=S(o,n?e:void 0);return t}),{});const{setup:c,read:u,resolveKeyframes:l,preUpdate:h,update:d,preRender:f,render:m,postRender:p}=a;const g=()=>{const o=t.useManualTiming?r.timestamp:performance.now();s=false;t.useManualTiming||(r.delta=i?1e3/60:Math.max(Math.min(o-r.timestamp,E),1));r.timestamp=o;r.isProcessing=true;c.process(r);u.process(r);l.process(r);h.process(r);d.process(r);f.process(r);m.process(r);p.process(r);r.isProcessing=false;if(s&&n){i=false;e(g)}};const y=()=>{s=true;i=true;r.isProcessing||e(g)};const v=M.reduce(((t,e)=>{const n=a[e];t[e]=(t,e=false,i=false)=>{s||y();return n.schedule(t,e,i)};return t}),{});const w=t=>{for(let e=0;e<M.length;e++)a[M[e]].cancel(t)};return{schedule:v,cancel:w,state:r,steps:a}}const{schedule:D,cancel:R,state:V,steps:F}=P(typeof requestAnimationFrame!=="undefined"?requestAnimationFrame:e,true);let O;function W(){O=void 0}const N={now:()=>{O===void 0&&N.set(V.isProcessing||t.useManualTiming?V.timestamp:performance.now());return O},set:t=>{O=t;queueMicrotask(W)}};const K={layout:0,mainThread:0,waapi:0};const C=t=>e=>typeof e==="string"&&e.startsWith(t);const $=C("--");const L=C("var(--");const B=t=>{const e=L(t);return!!e&&j.test(t.split("/*")[0].trim())};const j=/var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;const Y={test:t=>typeof t==="number",parse:parseFloat,transform:t=>t};const X={...Y,transform:t=>n(0,1,t)};const I={...Y,default:1};const z=t=>Math.round(t*1e5)/1e5;const U=/-?(?:\d+(?:\.\d+)?|\.\d+)/gu;function q(t){return t==null}const Z=/^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;const _=(t,e)=>n=>Boolean(typeof n==="string"&&Z.test(n)&&n.startsWith(t)||e&&!q(n)&&Object.prototype.hasOwnProperty.call(n,e));const G=(t,e,n)=>s=>{if(typeof s!=="string")return s;const[i,r,o,a]=s.match(U);return{[t]:parseFloat(i),[e]:parseFloat(r),[n]:parseFloat(o),alpha:a!==void 0?parseFloat(a):1}};const H=t=>n(0,255,t);const J={...Y,transform:t=>Math.round(H(t))};const Q={test:_("rgb","red"),parse:G("red","green","blue"),transform:({red:t,green:e,blue:n,alpha:s=1})=>"rgba("+J.transform(t)+", "+J.transform(e)+", "+J.transform(n)+", "+z(X.transform(s))+")"};function tt(t){let e="";let n="";let s="";let i="";if(t.length>5){e=t.substring(1,3);n=t.substring(3,5);s=t.substring(5,7);i=t.substring(7,9)}else{e=t.substring(1,2);n=t.substring(2,3);s=t.substring(3,4);i=t.substring(4,5);e+=e;n+=n;s+=s;i+=i}return{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(s,16),alpha:i?parseInt(i,16)/255:1}}const et={test:_("#"),parse:tt,transform:Q.transform};const nt=t=>({test:e=>typeof e==="string"&&e.endsWith(t)&&e.split(" ").length===1,parse:parseFloat,transform:e=>`${e}${t}`});const st=nt("deg");const it=nt("%");const rt=nt("px");const ot=nt("vh");const at=nt("vw");const ct=(()=>({...it,parse:t=>it.parse(t)/100,transform:t=>it.transform(t*100)}))();const ut={test:_("hsl","hue"),parse:G("hue","saturation","lightness"),transform:({hue:t,saturation:e,lightness:n,alpha:s=1})=>"hsla("+Math.round(t)+", "+it.transform(z(e))+", "+it.transform(z(n))+", "+z(X.transform(s))+")"};const lt={test:t=>Q.test(t)||et.test(t)||ut.test(t),parse:t=>Q.test(t)?Q.parse(t):ut.test(t)?ut.parse(t):et.parse(t),transform:t=>typeof t==="string"?t:t.hasOwnProperty("red")?Q.transform(t):ut.transform(t),getAnimatableNone:t=>{const e=lt.parse(t);e.alpha=0;return lt.transform(e)}};const ht=/(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;function dt(t){return isNaN(t)&&typeof t==="string"&&(t.match(U)?.length||0)+(t.match(ht)?.length||0)>0}const ft="number";const mt="color";const pt="var";const gt="var(";const yt="${}";const vt=/var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;function wt(t){const e=t.toString();const n=[];const s={color:[],number:[],var:[]};const i=[];let r=0;const o=e.replace(vt,(t=>{if(lt.test(t)){s.color.push(r);i.push(mt);n.push(lt.parse(t))}else if(t.startsWith(gt)){s.var.push(r);i.push(pt);n.push(t)}else{s.number.push(r);i.push(ft);n.push(parseFloat(t))}++r;return yt}));const a=o.split(yt);return{values:n,split:a,indexes:s,types:i}}function bt(t){return wt(t).values}function Tt(t){const{split:e,types:n}=wt(t);const s=e.length;return t=>{let i="";for(let r=0;r<s;r++){i+=e[r];if(t[r]!==void 0){const e=n[r];i+=e===ft?z(t[r]):e===mt?lt.transform(t[r]):t[r]}}return i}}const At=t=>typeof t==="number"?0:lt.test(t)?lt.getAnimatableNone(t):t;function xt(t){const e=bt(t);const n=Tt(t);return n(e.map(At))}const Mt={test:dt,parse:bt,createTransformer:Tt,getAnimatableNone:xt};function kt(t,e,n){n<0&&(n+=1);n>1&&(n-=1);return n<1/6?t+6*(e-t)*n:n<.5?e:n<2/3?t+(e-t)*(2/3-n)*6:t}function St({hue:t,saturation:e,lightness:n,alpha:s}){t/=360;e/=100;n/=100;let i=0;let r=0;let o=0;if(e){const s=n<.5?n*(1+e):n+e-n*e;const a=2*n-s;i=kt(a,s,t+1/3);r=kt(a,s,t);o=kt(a,s,t-1/3)}else i=r=o=n;return{red:Math.round(i*255),green:Math.round(r*255),blue:Math.round(o*255),alpha:s}}function Et(t,e){return n=>n>0?e:t}
/*
  Value in range from progress

  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (usually a number from 0 to 1)

  So progress = 0.5 would change

  from -------- to

  to

  from ---- to

  E.g. from = 10, to = 20, progress = 0.5 => 15

  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @param [number]: The progress between lower and upper limits expressed 0-1
  @return [number]: Value as calculated from progress within range (not limited within range)
*/const Pt=(t,e,n)=>t+(e-t)*n;const Dt=(t,e,n)=>{const s=t*t;const i=n*(e*e-s)+s;return i<0?0:Math.sqrt(i)};const Rt=[et,Q,ut];const Vt=t=>Rt.find((e=>e.test(t)));function Ft(t){const e=Vt(t);s(Boolean(e),`'${t}' is not an animatable color. Use the equivalent color code instead.`,"color-not-animatable");if(!Boolean(e))return false;let n=e.parse(t);e===ut&&(n=St(n));return n}const Ot=(t,e)=>{const n=Ft(t);const s=Ft(e);if(!n||!s)return Et(t,e);const i={...n};return t=>{i.red=Dt(n.red,s.red,t);i.green=Dt(n.green,s.green,t);i.blue=Dt(n.blue,s.blue,t);i.alpha=Pt(n.alpha,s.alpha,t);return Q.transform(i)}};const Wt=new Set(["none","hidden"]);function Nt(t,e){return Wt.has(t)?n=>n<=0?t:e:n=>n>=1?e:t}function Kt(t,e){return n=>Pt(t,e,n)}function Ct(t){return typeof t==="number"?Kt:typeof t==="string"?B(t)?Et:lt.test(t)?Ot:jt:Array.isArray(t)?$t:typeof t==="object"?lt.test(t)?Ot:Lt:Et}function $t(t,e){const n=[...t];const s=n.length;const i=t.map(((t,n)=>Ct(t)(t,e[n])));return t=>{for(let e=0;e<s;e++)n[e]=i[e](t);return n}}function Lt(t,e){const n={...t,...e};const s={};for(const i in n)t[i]!==void 0&&e[i]!==void 0&&(s[i]=Ct(t[i])(t[i],e[i]));return t=>{for(const e in s)n[e]=s[e](t);return n}}function Bt(t,e){const n=[];const s={color:0,var:0,number:0};for(let i=0;i<e.values.length;i++){const r=e.types[i];const o=t.indexes[r][s[r]];const a=t.values[o]??0;n[i]=a;s[r]++}return n}const jt=(t,e)=>{const n=Mt.createTransformer(e);const r=wt(t);const o=wt(e);const a=r.indexes.var.length===o.indexes.var.length&&r.indexes.color.length===o.indexes.color.length&&r.indexes.number.length>=o.indexes.number.length;if(a)return Wt.has(t)&&!o.values.length||Wt.has(e)&&!r.values.length?Nt(t,e):i($t(Bt(r,o),o.values),n);s(true,`Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`,"complex-values-different");return Et(t,e)};function Yt(t,e,n){if(typeof t==="number"&&typeof e==="number"&&typeof n==="number")return Pt(t,e,n);const s=Ct(t);return s(t,e)}const Xt=t=>{const e=({timestamp:e})=>t(e);return{start:(t=true)=>D.update(e,t),stop:()=>R(e),now:()=>V.isProcessing?V.timestamp:N.now()}};const It=(t,e,n=10)=>{let s="";const i=Math.max(Math.round(e/n),2);for(let e=0;e<i;e++)s+=Math.round(t(e/(i-1))*1e4)/1e4+", ";return`linear(${s.substring(0,s.length-2)})`};const zt=2e4;function Ut(t){let e=0;const n=50;let s=t.next(e);while(!s.done&&e<zt){e+=n;s=t.next(e)}return e>=zt?Infinity:e}function qt(t,e=100,n){const s=n({...t,keyframes:[0,e]});const i=Math.min(Ut(s),zt);return{type:"keyframes",ease:t=>s.next(i*t).value/e,duration:r(i)}}const Zt=5;function _t(t,e,n){const s=Math.max(e-Zt,0);return o(n-t(s),e-s)}const Gt={stiffness:100,damping:10,mass:1,velocity:0,duration:800,bounce:.3,visualDuration:.3,restSpeed:{granular:.01,default:2},restDelta:{granular:.005,default:.5},minDuration:.01,maxDuration:10,minDamping:.05,maxDamping:1};const Ht=.001;function Jt({duration:t=Gt.duration,bounce:e=Gt.bounce,velocity:i=Gt.velocity,mass:o=Gt.mass}){let c;let u;s(t<=a(Gt.maxDuration),"Spring duration must be 10 seconds or less","spring-duration-limit");let l=1-e;l=n(Gt.minDamping,Gt.maxDamping,l);t=n(Gt.minDuration,Gt.maxDuration,r(t));if(l<1){c=e=>{const n=e*l;const s=n*t;const r=n-i;const o=ee(e,l);const a=Math.exp(-s);return Ht-r/o*a};u=e=>{const n=e*l;const s=n*t;const r=s*i+i;const o=Math.pow(l,2)*Math.pow(e,2)*t;const a=Math.exp(-s);const u=ee(Math.pow(e,2),l);const h=-c(e)+Ht>0?-1:1;return h*((r-o)*a)/u}}else{c=e=>{const n=Math.exp(-e*t);const s=(e-i)*t+1;return n*s-Ht};u=e=>{const n=Math.exp(-e*t);const s=t*t*(i-e);return n*s}}const h=5/t;const d=te(c,u,h);t=a(t);if(isNaN(d))return{stiffness:Gt.stiffness,damping:Gt.damping,duration:t};{const e=Math.pow(d,2)*o;return{stiffness:e,damping:l*2*Math.sqrt(o*e),duration:t}}}const Qt=12;function te(t,e,n){let s=n;for(let n=1;n<Qt;n++)s-=t(s)/e(s);return s}function ee(t,e){return t*Math.sqrt(1-e*e)}const ne=["duration","bounce"];const se=["stiffness","damping","mass"];function ie(t,e){return e.some((e=>t[e]!==void 0))}function re(t){let e={velocity:Gt.velocity,stiffness:Gt.stiffness,damping:Gt.damping,mass:Gt.mass,isResolvedFromDuration:false,...t};if(!ie(t,se)&&ie(t,ne))if(t.visualDuration){const s=t.visualDuration;const i=2*Math.PI/(s*1.2);const r=i*i;const o=2*n(.05,1,1-(t.bounce||0))*Math.sqrt(r);e={...e,mass:Gt.mass,stiffness:r,damping:o}}else{const n=Jt(t);e={...e,...n,mass:Gt.mass};e.isResolvedFromDuration=true}return e}function oe(t=Gt.visualDuration,e=Gt.bounce){const n=typeof t!=="object"?{visualDuration:t,keyframes:[0,1],bounce:e}:t;let{restSpeed:s,restDelta:i}=n;const o=n.keyframes[0];const c=n.keyframes[n.keyframes.length-1];const u={done:false,value:o};const{stiffness:l,damping:h,mass:d,duration:f,velocity:m,isResolvedFromDuration:p}=re({...n,velocity:-r(n.velocity||0)});const g=m||0;const y=h/(2*Math.sqrt(l*d));const v=c-o;const w=r(Math.sqrt(l/d));const b=Math.abs(v)<5;s||(s=b?Gt.restSpeed.granular:Gt.restSpeed.default);i||(i=b?Gt.restDelta.granular:Gt.restDelta.default);let T;if(y<1){const t=ee(w,y);T=e=>{const n=Math.exp(-y*w*e);return c-n*((g+y*w*v)/t*Math.sin(t*e)+v*Math.cos(t*e))}}else if(y===1)T=t=>c-Math.exp(-w*t)*(v+(g+w*v)*t);else{const t=w*Math.sqrt(y*y-1);T=e=>{const n=Math.exp(-y*w*e);const s=Math.min(t*e,300);return c-n*((g+y*w*v)*Math.sinh(s)+t*v*Math.cosh(s))/t}}const A={calculatedDuration:p&&f||null,next:t=>{const e=T(t);if(p)u.done=t>=f;else{let n=t===0?g:0;y<1&&(n=t===0?a(g):_t(T,t,e));const r=Math.abs(n)<=s;const o=Math.abs(c-e)<=i;u.done=r&&o}u.value=u.done?c:e;return u},toString:()=>{const t=Math.min(Ut(A),zt);const e=It((e=>A.next(t*e).value),t,30);return t+"ms "+e},toTransition:()=>{}};return A}oe.applyToOptions=t=>{const e=qt(t,100,oe);t.ease=e.ease;t.duration=a(e.duration);t.type="keyframes";return t};function ae({keyframes:t,velocity:e=0,power:n=.8,timeConstant:s=325,bounceDamping:i=10,bounceStiffness:r=500,modifyTarget:o,min:a,max:c,restDelta:u=.5,restSpeed:l}){const h=t[0];const d={done:false,value:h};const f=t=>a!==void 0&&t<a||c!==void 0&&t>c;const m=t=>a===void 0?c:c===void 0||Math.abs(a-t)<Math.abs(c-t)?a:c;let p=n*e;const g=h+p;const y=o===void 0?g:o(g);y!==g&&(p=y-h);const v=t=>-p*Math.exp(-t/s);const w=t=>y+v(t);const b=t=>{const e=v(t);const n=w(t);d.done=Math.abs(e)<=u;d.value=d.done?y:n};let T;let A;const x=t=>{if(f(d.value)){T=t;A=oe({keyframes:[d.value,m(d.value)],velocity:_t(w,t,d.value),damping:i,stiffness:r,restDelta:u,restSpeed:l})}};x(0);return{calculatedDuration:null,next:t=>{let e=false;if(!A&&T===void 0){e=true;b(t);x(t)}if(T!==void 0&&t>=T)return A.next(t-T);!e&&b(t);return d}}}function ce(n,s,r){const o=[];const a=r||t.mix||Yt;const c=n.length-1;for(let t=0;t<c;t++){let r=a(n[t],n[t+1]);if(s){const n=Array.isArray(s)?s[t]||e:s;r=i(n,r)}o.push(r)}return o}function ue(t,e,{clamp:s=true,ease:i,mixer:r}={}){const o=t.length;c(o===e.length,"Both input and output ranges must be the same length","range-length");if(o===1)return()=>e[0];if(o===2&&e[0]===e[1])return()=>e[1];const a=t[0]===t[1];if(t[0]>t[o-1]){t=[...t].reverse();e=[...e].reverse()}const l=ce(e,i,r);const h=l.length;const d=n=>{if(a&&n<t[0])return e[0];let s=0;if(h>1)for(;s<t.length-2;s++)if(n<t[s+1])break;const i=u(t[s],t[s+1],n);return l[s](i)};return s?e=>d(n(t[0],t[o-1],e)):d}function le(t,e){const n=t[t.length-1];for(let s=1;s<=e;s++){const i=u(0,e,s);t.push(Pt(n,1,i))}}function he(t){const e=[0];le(e,t.length-1);return e}function de(t,e){return t.map((t=>t*e))}function fe(t,e){return t.map((()=>e||l)).splice(0,t.length-1)}function me({duration:t=300,keyframes:e,times:n,ease:s="easeInOut"}){const i=h(s)?s.map(d):d(s);const r={done:false,value:e[0]};const o=de(n&&n.length===e.length?n:he(e),t);const a=ue(o,e,{ease:Array.isArray(i)?i:fe(e,i)});return{calculatedDuration:t,next:e=>{r.value=a(e);r.done=e>=t;return r}}}const pe=t=>t!==null;function ge(t,{repeat:e,repeatType:n="loop"},s,i=1){const r=t.filter(pe);const o=i<0||e&&n!=="loop"&&e%2===1;const a=o?0:r.length-1;return a&&s!==void 0?s:r[a]}const ye={decay:ae,inertia:ae,tween:me,keyframes:me,spring:oe};function ve(t){typeof t.type==="string"&&(t.type=ye[t.type])}class WithPromise{constructor(){this.updateFinished()}get finished(){return this._finished}updateFinished(){this._finished=new Promise((t=>{this.resolve=t}))}notifyFinished(){this.resolve()}
/**
     * Allows the animation to be awaited.
     *
     * @deprecated Use `finished` instead.
     */then(t,e){return this.finished.then(t,e)}}const we=t=>t/100;class JSAnimation extends WithPromise{constructor(t){super();this.state="idle";this.startTime=null;this.isStopped=false;this.currentTime=0;this.holdTime=null;this.playbackSpeed=1;this.stop=()=>{const{motionValue:t}=this.options;t&&t.updatedAt!==N.now()&&this.tick(N.now());this.isStopped=true;if(this.state!=="idle"){this.teardown();this.options.onStop?.()}};K.mainThread++;this.options=t;this.initAnimation();this.play();t.autoplay===false&&this.pause()}initAnimation(){const{options:t}=this;ve(t);const{type:e=me,repeat:n=0,repeatDelay:s=0,repeatType:r,velocity:o=0}=t;let{keyframes:a}=t;const u=e||me;process.env.NODE_ENV!=="production"&&u!==me&&c(a.length<=2,`Only two keyframes currently supported with spring and inertia animations. Trying to animate ${a}`,"spring-two-frames");if(u!==me&&typeof a[0]!=="number"){this.mixKeyframes=i(we,Yt(a[0],a[1]));a=[0,100]}const l=u({...t,keyframes:a});r==="mirror"&&(this.mirroredGenerator=u({...t,keyframes:[...a].reverse(),velocity:-o}));l.calculatedDuration===null&&(l.calculatedDuration=Ut(l));const{calculatedDuration:h}=l;this.calculatedDuration=h;this.resolvedDuration=h+s;this.totalDuration=this.resolvedDuration*(n+1)-s;this.generator=l}updateTime(t){const e=Math.round(t-this.startTime)*this.playbackSpeed;this.holdTime!==null?this.currentTime=this.holdTime:this.currentTime=e}tick(t,e=false){const{generator:s,totalDuration:i,mixKeyframes:r,mirroredGenerator:o,resolvedDuration:a,calculatedDuration:c}=this;if(this.startTime===null)return s.next(0);const{delay:u=0,keyframes:l,repeat:h,repeatType:d,repeatDelay:f,type:m,onUpdate:p,finalKeyframe:g}=this.options;this.speed>0?this.startTime=Math.min(this.startTime,t):this.speed<0&&(this.startTime=Math.min(t-i/this.speed,this.startTime));e?this.currentTime=t:this.updateTime(t);const y=this.currentTime-u*(this.playbackSpeed>=0?1:-1);const v=this.playbackSpeed>=0?y<0:y>i;this.currentTime=Math.max(y,0);this.state==="finished"&&this.holdTime===null&&(this.currentTime=i);let w=this.currentTime;let b=s;if(h){const t=Math.min(this.currentTime,i)/a;let e=Math.floor(t);let s=t%1;!s&&t>=1&&(s=1);s===1&&e--;e=Math.min(e,h+1);const r=Boolean(e%2);if(r)if(d==="reverse"){s=1-s;f&&(s-=f/a)}else d==="mirror"&&(b=o);w=n(0,1,s)*a}const T=v?{done:false,value:l[0]}:b.next(w);r&&(T.value=r(T.value));let{done:A}=T;v||c===null||(A=this.playbackSpeed>=0?this.currentTime>=i:this.currentTime<=0);const x=this.holdTime===null&&(this.state==="finished"||this.state==="running"&&A);x&&m!==ae&&(T.value=ge(l,this.options,g,this.speed));p&&p(T.value);x&&this.finish();return T}then(t,e){return this.finished.then(t,e)}get duration(){return r(this.calculatedDuration)}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+r(t)}get time(){return r(this.currentTime)}set time(t){t=a(t);this.currentTime=t;this.startTime===null||this.holdTime!==null||this.playbackSpeed===0?this.holdTime=t:this.driver&&(this.startTime=this.driver.now()-t/this.playbackSpeed);this.driver?.start(false)}get speed(){return this.playbackSpeed}set speed(t){this.updateTime(N.now());const e=this.playbackSpeed!==t;this.playbackSpeed=t;e&&(this.time=r(this.currentTime))}play(){if(this.isStopped)return;const{driver:t=Xt,startTime:e}=this.options;this.driver||(this.driver=t((t=>this.tick(t))));this.options.onPlay?.();const n=this.driver.now();if(this.state==="finished"){this.updateFinished();this.startTime=n}else this.holdTime!==null?this.startTime=n-this.holdTime:this.startTime||(this.startTime=e??n);this.state==="finished"&&this.speed<0&&(this.startTime+=this.calculatedDuration);this.holdTime=null;this.state="running";this.driver.start()}pause(){this.state="paused";this.updateTime(N.now());this.holdTime=this.currentTime}complete(){this.state!=="running"&&this.play();this.state="finished";this.holdTime=null}finish(){this.notifyFinished();this.teardown();this.state="finished";this.options.onComplete?.()}cancel(){this.holdTime=null;this.startTime=0;this.tick(0);this.teardown();this.options.onCancel?.()}teardown(){this.state="idle";this.stopDriver();this.startTime=this.holdTime=null;K.mainThread--}stopDriver(){if(this.driver){this.driver.stop();this.driver=void 0}}sample(t){this.startTime=0;return this.tick(t,true)}attachTimeline(t){if(this.options.allowFlatten){this.options.type="keyframes";this.options.ease="linear";this.initAnimation()}this.driver?.stop();return t.observe(this)}}function be(t){return new JSAnimation(t)}function Te(t){for(let e=1;e<t.length;e++)t[e]??(t[e]=t[e-1])}const Ae=t=>t*180/Math.PI;const xe=t=>{const e=Ae(Math.atan2(t[1],t[0]));return ke(e)};const Me={x:4,y:5,translateX:4,translateY:5,scaleX:0,scaleY:3,scale:t=>(Math.abs(t[0])+Math.abs(t[3]))/2,rotate:xe,rotateZ:xe,skewX:t=>Ae(Math.atan(t[1])),skewY:t=>Ae(Math.atan(t[2])),skew:t=>(Math.abs(t[1])+Math.abs(t[2]))/2};const ke=t=>{t%=360;t<0&&(t+=360);return t};const Se=xe;const Ee=t=>Math.sqrt(t[0]*t[0]+t[1]*t[1]);const Pe=t=>Math.sqrt(t[4]*t[4]+t[5]*t[5]);const De={x:12,y:13,z:14,translateX:12,translateY:13,translateZ:14,scaleX:Ee,scaleY:Pe,scale:t=>(Ee(t)+Pe(t))/2,rotateX:t=>ke(Ae(Math.atan2(t[6],t[5]))),rotateY:t=>ke(Ae(Math.atan2(-t[2],t[0]))),rotateZ:Se,rotate:Se,skewX:t=>Ae(Math.atan(t[4])),skewY:t=>Ae(Math.atan(t[1])),skew:t=>(Math.abs(t[1])+Math.abs(t[4]))/2};function Re(t){return t.includes("scale")?1:0}function Ve(t,e){if(!t||t==="none")return Re(e);const n=t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);let s;let i;if(n){s=De;i=n}else{const e=t.match(/^matrix\(([-\d.e\s,]+)\)$/u);s=Me;i=e}if(!i)return Re(e);const r=s[e];const o=i[1].split(",").map(Oe);return typeof r==="function"?r(o):o[r]}const Fe=(t,e)=>{const{transform:n="none"}=getComputedStyle(t);return Ve(n,e)};function Oe(t){return parseFloat(t.trim())}const We=["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"];const Ne=(()=>new Set(We))();const Ke=t=>t===Y||t===rt;const Ce=new Set(["x","y","z"]);const $e=We.filter((t=>!Ce.has(t)));function Le(t){const e=[];$e.forEach((n=>{const s=t.getValue(n);if(s!==void 0){e.push([n,s.get()]);s.set(n.startsWith("scale")?1:0)}}));return e}const Be={width:({x:t},{paddingLeft:e="0",paddingRight:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),height:({y:t},{paddingTop:e="0",paddingBottom:n="0"})=>t.max-t.min-parseFloat(e)-parseFloat(n),top:(t,{top:e})=>parseFloat(e),left:(t,{left:e})=>parseFloat(e),bottom:({y:t},{top:e})=>parseFloat(e)+(t.max-t.min),right:({x:t},{left:e})=>parseFloat(e)+(t.max-t.min),x:(t,{transform:e})=>Ve(e,"x"),y:(t,{transform:e})=>Ve(e,"y")};Be.translateX=Be.x;Be.translateY=Be.y;const je=new Set;let Ye=false;let Xe=false;let Ie=false;function ze(){if(Xe){const t=Array.from(je).filter((t=>t.needsMeasurement));const e=new Set(t.map((t=>t.element)));const n=new Map;e.forEach((t=>{const e=Le(t);if(e.length){n.set(t,e);t.render()}}));t.forEach((t=>t.measureInitialState()));e.forEach((t=>{t.render();const e=n.get(t);e&&e.forEach((([e,n])=>{t.getValue(e)?.set(n)}))}));t.forEach((t=>t.measureEndState()));t.forEach((t=>{t.suspendedScrollY!==void 0&&window.scrollTo(0,t.suspendedScrollY)}))}Xe=false;Ye=false;je.forEach((t=>t.complete(Ie)));je.clear()}function Ue(){je.forEach((t=>{t.readKeyframes();t.needsMeasurement&&(Xe=true)}))}function qe(){Ie=true;Ue();ze();Ie=false}class KeyframeResolver{constructor(t,e,n,s,i,r=false){this.state="pending";this.isAsync=false;this.needsMeasurement=false;this.unresolvedKeyframes=[...t];this.onComplete=e;this.name=n;this.motionValue=s;this.element=i;this.isAsync=r}scheduleResolve(){this.state="scheduled";if(this.isAsync){je.add(this);if(!Ye){Ye=true;D.read(Ue);D.resolveKeyframes(ze)}}else{this.readKeyframes();this.complete()}}readKeyframes(){const{unresolvedKeyframes:t,name:e,element:n,motionValue:s}=this;if(t[0]===null){const i=s?.get();const r=t[t.length-1];if(i!==void 0)t[0]=i;else if(n&&e){const s=n.readValue(e,r);s!==void 0&&s!==null&&(t[0]=s)}t[0]===void 0&&(t[0]=r);s&&i===void 0&&s.set(t[0])}Te(t)}setFinalKeyframe(){}measureInitialState(){}renderEndStyles(){}measureEndState(){}complete(t=false){this.state="complete";this.onComplete(this.unresolvedKeyframes,this.finalKeyframe,t);je.delete(this)}cancel(){if(this.state==="scheduled"){je.delete(this);this.state="pending"}}resume(){this.state==="pending"&&this.scheduleResolve()}}const Ze=t=>t.startsWith("--");function _e(t,e,n){Ze(e)?t.style.setProperty(e,n):t.style[e]=n}const Ge=f((()=>window.ScrollTimeline!==void 0));const He={};function Je(t,e){const n=f(t);return()=>He[e]??n()}const Qe=Je((()=>{try{document.createElement("div").animate({opacity:0},{easing:"linear(0, 1)"})}catch(t){return false}return true}),"linearEasing");const tn=([t,e,n,s])=>`cubic-bezier(${t}, ${e}, ${n}, ${s})`;const en={linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:tn([0,.65,.55,1]),circOut:tn([.55,0,1,.45]),backIn:tn([.31,.01,.66,-.59]),backOut:tn([.33,1.53,.69,.99])};function nn(t,e){return t?typeof t==="function"?Qe()?It(t,e):"ease-out":m(t)?tn(t):Array.isArray(t)?t.map((t=>nn(t,e)||en.easeOut)):en[t]:void 0}function sn(t,e,n,{delay:s=0,duration:i=300,repeat:r=0,repeatType:o="loop",ease:a="easeOut",times:c}={},u=void 0){const l={[e]:n};c&&(l.offset=c);const h=nn(a,i);Array.isArray(h)&&(l.easing=h);k.value&&K.waapi++;const d={delay:s,duration:i,easing:Array.isArray(h)?"linear":h,fill:"both",iterations:r+1,direction:o==="reverse"?"alternate":"normal"};u&&(d.pseudoElement=u);const f=t.animate(l,d);k.value&&f.finished.finally((()=>{K.waapi--}));return f}function rn(t){return typeof t==="function"&&"applyToOptions"in t}function on({type:t,...e}){if(rn(t)&&Qe())return t.applyToOptions(e);e.duration??(e.duration=300);e.ease??(e.ease="easeOut");return e}class NativeAnimation extends WithPromise{constructor(t){super();this.finishedTime=null;this.isStopped=false;if(!t)return;const{element:e,name:n,keyframes:s,pseudoElement:i,allowFlatten:r=false,finalKeyframe:o,onComplete:a}=t;this.isPseudoElement=Boolean(i);this.allowFlatten=r;this.options=t;c(typeof t.type!=="string",'Mini animate() doesn\'t support "type" as a string.',"mini-spring");const u=on(t);this.animation=sn(e,n,s,u,i);u.autoplay===false&&this.animation.pause();this.animation.onfinish=()=>{this.finishedTime=this.time;if(!i){const t=ge(s,this.options,o,this.speed);this.updateMotionValue?this.updateMotionValue(t):_e(e,n,t);this.animation.cancel()}a?.();this.notifyFinished()}}play(){if(!this.isStopped){this.animation.play();this.state==="finished"&&this.updateFinished()}}pause(){this.animation.pause()}complete(){this.animation.finish?.()}cancel(){try{this.animation.cancel()}catch(t){}}stop(){if(this.isStopped)return;this.isStopped=true;const{state:t}=this;if(t!=="idle"&&t!=="finished"){this.updateMotionValue?this.updateMotionValue():this.commitStyles();this.isPseudoElement||this.cancel()}}commitStyles(){this.isPseudoElement||this.animation.commitStyles?.()}get duration(){const t=this.animation.effect?.getComputedTiming?.().duration||0;return r(Number(t))}get iterationDuration(){const{delay:t=0}=this.options||{};return this.duration+r(t)}get time(){return r(Number(this.animation.currentTime)||0)}set time(t){this.finishedTime=null;this.animation.currentTime=a(t)}get speed(){return this.animation.playbackRate}set speed(t){t<0&&(this.finishedTime=null);this.animation.playbackRate=t}get state(){return this.finishedTime!==null?"finished":this.animation.playState}get startTime(){return Number(this.animation.startTime)}set startTime(t){this.animation.startTime=t}attachTimeline({timeline:t,observe:n}){this.allowFlatten&&this.animation.effect?.updateTiming({easing:"linear"});this.animation.onfinish=null;if(t&&Ge()){this.animation.timeline=t;return e}return n(this)}}const an={anticipate:y,backInOut:g,circInOut:p};function cn(t){return t in an}function un(t){typeof t.ease==="string"&&cn(t.ease)&&(t.ease=an[t.ease])}const ln=10;class NativeAnimationExtended extends NativeAnimation{constructor(t){un(t);ve(t);super(t);t.startTime&&(this.startTime=t.startTime);this.options=t}updateMotionValue(t){const{motionValue:e,onUpdate:n,onComplete:s,element:i,...r}=this.options;if(!e)return;if(t!==void 0){e.set(t);return}const o=new JSAnimation({...r,autoplay:false});const c=a(this.finishedTime??this.time);e.setWithVelocity(o.sample(c-ln).value,o.sample(c).value,ln);o.stop()}}
/**
 * Check if a value is animatable. Examples:
 *
 * ✅: 100, "100px", "#fff"
 * ❌: "block", "url(2.jpg)"
 * @param value
 *
 * @internal
 */const hn=(t,e)=>e!=="zIndex"&&(!(typeof t!=="number"&&!Array.isArray(t))||!(typeof t!=="string"||!Mt.test(t)&&t!=="0"||t.startsWith("url(")));function dn(t){const e=t[0];if(t.length===1)return true;for(let n=0;n<t.length;n++)if(t[n]!==e)return true}function fn(t,e,n,i){const r=t[0];if(r===null)return false;if(e==="display"||e==="visibility")return true;const o=t[t.length-1];const a=hn(r,e);const c=hn(o,e);s(a===c,`You are trying to animate ${e} from "${r}" to "${o}". "${a?o:r}" is not an animatable value.`,"value-not-animatable");return!(!a||!c)&&(dn(t)||(n==="spring"||rn(n))&&i)}function mn(t){t.duration=0;t.type="keyframes"}const pn=new Set(["opacity","clipPath","filter","transform"]);const gn=f((()=>Object.hasOwnProperty.call(Element.prototype,"animate")));function yn(t){const{motionValue:e,name:n,repeatDelay:s,repeatType:i,damping:r,type:o}=t;const a=e?.owner?.current;if(!(a instanceof HTMLElement))return false;const{onUpdate:c,transformTemplate:u}=e.owner.getProps();return gn()&&n&&pn.has(n)&&(n!=="transform"||!u)&&!c&&!s&&i!=="mirror"&&r!==0&&o!=="inertia"}const vn=40;class AsyncMotionValueAnimation extends WithPromise{constructor({autoplay:t=true,delay:e=0,type:n="keyframes",repeat:s=0,repeatDelay:i=0,repeatType:r="loop",keyframes:o,name:a,motionValue:c,element:u,...l}){super();this.stop=()=>{if(this._animation){this._animation.stop();this.stopTimeline?.()}this.keyframeResolver?.cancel()};this.createdAt=N.now();const h={autoplay:t,delay:e,type:n,repeat:s,repeatDelay:i,repeatType:r,name:a,motionValue:c,element:u,...l};const d=u?.KeyframeResolver||KeyframeResolver;this.keyframeResolver=new d(o,((t,e,n)=>this.onKeyframesResolved(t,e,h,!n)),a,c,u);this.keyframeResolver?.scheduleResolve()}onKeyframesResolved(n,s,i,r){this.keyframeResolver=void 0;const{name:o,type:a,velocity:c,delay:u,isHandoff:l,onUpdate:h}=i;this.resolvedAt=N.now();if(!fn(n,o,a,c)){!t.instantAnimations&&u||h?.(ge(n,i,s));n[0]=n[n.length-1];mn(i);i.repeat=0}const d=r?this.resolvedAt&&this.resolvedAt-this.createdAt>vn?this.resolvedAt:this.createdAt:void 0;const f={startTime:d,finalKeyframe:s,...i,keyframes:n};const m=!l&&yn(f)?new NativeAnimationExtended({...f,element:f.motionValue.owner.current}):new JSAnimation(f);m.finished.then((()=>this.notifyFinished())).catch(e);if(this.pendingTimeline){this.stopTimeline=m.attachTimeline(this.pendingTimeline);this.pendingTimeline=void 0}this._animation=m}get finished(){return this._animation?this.animation.finished:this._finished}then(t,e){return this.finished.finally(t).then((()=>{}))}get animation(){if(!this._animation){this.keyframeResolver?.resume();qe()}return this._animation}get duration(){return this.animation.duration}get iterationDuration(){return this.animation.iterationDuration}get time(){return this.animation.time}set time(t){this.animation.time=t}get speed(){return this.animation.speed}get state(){return this.animation.state}set speed(t){this.animation.speed=t}get startTime(){return this.animation.startTime}attachTimeline(t){this._animation?this.stopTimeline=this.animation.attachTimeline(t):this.pendingTimeline=t;return()=>this.stop()}play(){this.animation.play()}pause(){this.animation.pause()}complete(){this.animation.complete()}cancel(){this._animation&&this.animation.cancel();this.keyframeResolver?.cancel()}}class GroupAnimation{constructor(t){this.stop=()=>this.runAll("stop");this.animations=t.filter(Boolean)}get finished(){return Promise.all(this.animations.map((t=>t.finished)))}getAll(t){return this.animations[0][t]}setAll(t,e){for(let n=0;n<this.animations.length;n++)this.animations[n][t]=e}attachTimeline(t){const e=this.animations.map((e=>e.attachTimeline(t)));return()=>{e.forEach(((t,e)=>{t&&t();this.animations[e].stop()}))}}get time(){return this.getAll("time")}set time(t){this.setAll("time",t)}get speed(){return this.getAll("speed")}set speed(t){this.setAll("speed",t)}get state(){return this.getAll("state")}get startTime(){return this.getAll("startTime")}get duration(){return wn(this.animations,"duration")}get iterationDuration(){return wn(this.animations,"iterationDuration")}runAll(t){this.animations.forEach((e=>e[t]()))}play(){this.runAll("play")}pause(){this.runAll("pause")}cancel(){this.runAll("cancel")}complete(){this.runAll("complete")}}function wn(t,e){let n=0;for(let s=0;s<t.length;s++){const i=t[s][e];i!==null&&i>n&&(n=i)}return n}class GroupAnimationWithThen extends GroupAnimation{then(t,e){return this.finished.finally(t).then((()=>{}))}}class NativeAnimationWrapper extends NativeAnimation{constructor(t){super();this.animation=t;t.onfinish=()=>{this.finishedTime=this.time;this.notifyFinished()}}}const bn=new WeakMap;const Tn=(t,e="")=>`${t}:${e}`;function An(t){const e=bn.get(t)||new Map;bn.set(t,e);return e}
/**
 * Parse Framer's special CSS variable format into a CSS token and a fallback.
 *
 * ```
 * `var(--foo, #fff)` => [`--foo`, '#fff']
 * ```
 *
 * @param current
 */const xn=/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;function Mn(t){const e=xn.exec(t);if(!e)return[,];const[,n,s,i]=e;return[`--${n??s}`,i]}const kn=4;function Sn(t,e,n=1){c(n<=kn,`Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`,"max-css-var-depth");const[s,i]=Mn(t);if(!s)return;const r=window.getComputedStyle(e).getPropertyValue(s);if(r){const t=r.trim();return v(t)?parseFloat(t):t}return B(i)?Sn(i,e,n+1):i}function En(t,e){return t?.[e]??t?.default??t}const Pn=new Set(["width","height","top","left","right","bottom",...We]);const Dn={test:t=>t==="auto",parse:t=>t};const Rn=t=>e=>e.test(t);const Vn=[Y,rt,it,st,at,ot,Dn];const Fn=t=>Vn.find(Rn(t));function On(t){return typeof t==="number"?t===0:t===null||(t==="none"||t==="0"||w(t))}const Wn=new Set(["brightness","contrast","saturate","opacity"]);function Nn(t){const[e,n]=t.slice(0,-1).split("(");if(e==="drop-shadow")return t;const[s]=n.match(U)||[];if(!s)return t;const i=n.replace(s,"");let r=Wn.has(e)?1:0;s!==n&&(r*=100);return e+"("+r+i+")"}const Kn=/\b([a-z-]*)\(.*?\)/gu;const Cn={...Mt,getAnimatableNone:t=>{const e=t.match(Kn);return e?e.map(Nn).join(" "):t}};const $n={...Y,transform:Math.round};const Ln={rotate:st,rotateX:st,rotateY:st,rotateZ:st,scale:I,scaleX:I,scaleY:I,scaleZ:I,skew:st,skewX:st,skewY:st,distance:rt,translateX:rt,translateY:rt,translateZ:rt,x:rt,y:rt,z:rt,perspective:rt,transformPerspective:rt,opacity:X,originX:ct,originY:ct,originZ:rt};const Bn={borderWidth:rt,borderTopWidth:rt,borderRightWidth:rt,borderBottomWidth:rt,borderLeftWidth:rt,borderRadius:rt,radius:rt,borderTopLeftRadius:rt,borderTopRightRadius:rt,borderBottomRightRadius:rt,borderBottomLeftRadius:rt,width:rt,maxWidth:rt,height:rt,maxHeight:rt,top:rt,right:rt,bottom:rt,left:rt,padding:rt,paddingTop:rt,paddingRight:rt,paddingBottom:rt,paddingLeft:rt,margin:rt,marginTop:rt,marginRight:rt,marginBottom:rt,marginLeft:rt,backgroundPositionX:rt,backgroundPositionY:rt,...Ln,zIndex:$n,fillOpacity:X,strokeOpacity:X,numOctaves:$n};const jn={...Bn,color:lt,backgroundColor:lt,outlineColor:lt,fill:lt,stroke:lt,borderColor:lt,borderTopColor:lt,borderRightColor:lt,borderBottomColor:lt,borderLeftColor:lt,filter:Cn,WebkitFilter:Cn};const Yn=t=>jn[t];function Xn(t,e){let n=Yn(t);n!==Cn&&(n=Mt);return n.getAnimatableNone?n.getAnimatableNone(e):void 0}const In=new Set(["auto","none","0"]);function zn(t,e,n){let s=0;let i;while(s<t.length&&!i){const e=t[s];typeof e==="string"&&!In.has(e)&&wt(e).values.length&&(i=t[s]);s++}if(i&&n)for(const s of e)t[s]=Xn(n,i)}class DOMKeyframesResolver extends KeyframeResolver{constructor(t,e,n,s,i){super(t,e,n,s,i,true)}readKeyframes(){const{unresolvedKeyframes:t,element:e,name:n}=this;if(!e||!e.current)return;super.readKeyframes();for(let n=0;n<t.length;n++){let s=t[n];if(typeof s==="string"){s=s.trim();if(B(s)){const i=Sn(s,e.current);i!==void 0&&(t[n]=i);n===t.length-1&&(this.finalKeyframe=s)}}}this.resolveNoneKeyframes();if(!Pn.has(n)||t.length!==2)return;const[s,i]=t;const r=Fn(s);const o=Fn(i);if(r!==o)if(Ke(r)&&Ke(o))for(let e=0;e<t.length;e++){const n=t[e];typeof n==="string"&&(t[e]=parseFloat(n))}else Be[n]&&(this.needsMeasurement=true)}resolveNoneKeyframes(){const{unresolvedKeyframes:t,name:e}=this;const n=[];for(let e=0;e<t.length;e++)(t[e]===null||On(t[e]))&&n.push(e);n.length&&zn(t,n,e)}measureInitialState(){const{element:t,unresolvedKeyframes:e,name:n}=this;if(!t||!t.current)return;n==="height"&&(this.suspendedScrollY=window.pageYOffset);this.measuredOrigin=Be[n](t.measureViewportBox(),window.getComputedStyle(t.current));e[0]=this.measuredOrigin;const s=e[e.length-1];s!==void 0&&t.getValue(n,s).jump(s,false)}measureEndState(){const{element:t,name:e,unresolvedKeyframes:n}=this;if(!t||!t.current)return;const s=t.getValue(e);s&&s.jump(this.measuredOrigin,false);const i=n.length-1;const r=n[i];n[i]=Be[e](t.measureViewportBox(),window.getComputedStyle(t.current));r!==null&&this.finalKeyframe===void 0&&(this.finalKeyframe=r);this.removedTransforms?.length&&this.removedTransforms.forEach((([e,n])=>{t.getValue(e).set(n)}));this.resolveNoneKeyframes()}}const Un=new Set(["borderWidth","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","borderRadius","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","width","maxWidth","height","maxHeight","top","right","bottom","left","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","margin","marginTop","marginRight","marginBottom","marginLeft","backgroundPositionX","backgroundPositionY"]);function qn(t,e){for(let n=0;n<t.length;n++)typeof t[n]==="number"&&Un.has(e)&&(t[n]=t[n]+"px")}function Zn(t){return Boolean(typeof t==="function"&&Qe()||!t||typeof t==="string"&&(t in en||Qe())||m(t)||Array.isArray(t)&&t.every(Zn))}const _n=f((()=>{try{document.createElement("div").animate({opacity:[1]})}catch(t){return false}return true}));const Gn=new Set(["opacity","clipPath","filter","transform"]);function Hn(t){return t.replace(/([A-Z])/g,(t=>`-${t.toLowerCase()}`))}function Jn(t,e,n){if(t instanceof EventTarget)return[t];if(typeof t==="string"){let s=document;e&&(s=e.current);const i=n?.[t]??s.querySelectorAll(t);return i?Array.from(i):[]}return Array.from(t)}function Qn(t){return(e,n)=>{const s=Jn(e);const i=[];for(const e of s){const s=t(e,n);i.push(s)}return()=>{for(const t of i)t()}}}const ts=(t,e)=>e&&typeof t==="number"?e.transform(t):t;class MotionValueState{constructor(){this.latest={};this.values=new Map}set(t,e,n,s,i=true){const r=this.values.get(t);r&&r.onRemove();const o=()=>{const s=e.get();this.latest[t]=i?ts(s,Bn[t]):s;n&&D.render(n)};o();const a=e.on("change",o);s&&e.addDependent(s);const c=()=>{a();n&&R(n);this.values.delete(t);s&&e.removeDependent(s)};this.values.set(t,{value:e,onRemove:c});return c}get(t){return this.values.get(t)?.value}destroy(){for(const t of this.values.values())t.onRemove()}}function es(t){const e=new WeakMap;const n=[];return(s,i)=>{const r=e.get(s)??new MotionValueState;e.set(s,r);for(const e in i){const o=i[e];const a=t(s,r,e,o);n.push(a)}return()=>{for(const t of n)t()}}}function ns(t,e){if(!(e in t))return false;const n=Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t),e)||Object.getOwnPropertyDescriptor(t,e);return n&&typeof n.set==="function"}const ss=(t,e,n,s)=>{const i=ns(t,n);const r=i?n:n.startsWith("data")||n.startsWith("aria")?Hn(n):n;const o=i?()=>{t[r]=e.latest[n]}:()=>{const s=e.latest[n];s===null||s===void 0?t.removeAttribute(r):t.setAttribute(r,String(s))};return e.set(n,s,o)};const is=Qn(es(ss));const rs=es(((t,e,n,s)=>e.set(n,s,(()=>{t[n]=e.latest[n]}),void 0,false)));function os(t){return b(t)&&"offsetHeight"in t}const as=30;const cs=t=>!isNaN(parseFloat(t));const us={current:void 0};class MotionValue{
/**
     * @param init - The initiating value
     * @param config - Optional configuration options
     *
     * -  `transformer`: A function to transform incoming values with.
     */
constructor(t,e={}){this.canTrackVelocity=null;this.events={};this.updateAndNotify=t=>{const e=N.now();this.updatedAt!==e&&this.setPrevFrameValue();this.prev=this.current;this.setCurrent(t);if(this.current!==this.prev){this.events.change?.notify(this.current);if(this.dependents)for(const t of this.dependents)t.dirty()}};this.hasAnimated=false;this.setCurrent(t);this.owner=e.owner}setCurrent(t){this.current=t;this.updatedAt=N.now();this.canTrackVelocity===null&&t!==void 0&&(this.canTrackVelocity=cs(this.current))}setPrevFrameValue(t=this.current){this.prevFrameValue=t;this.prevUpdatedAt=this.updatedAt}
/**
     * Adds a function that will be notified when the `MotionValue` is updated.
     *
     * It returns a function that, when called, will cancel the subscription.
     *
     * When calling `onChange` inside a React component, it should be wrapped with the
     * `useEffect` hook. As it returns an unsubscribe function, this should be returned
     * from the `useEffect` function to ensure you don't add duplicate subscribers..
     *
     * ```jsx
     * export const MyComponent = () => {
     *   const x = useMotionValue(0)
     *   const y = useMotionValue(0)
     *   const opacity = useMotionValue(1)
     *
     *   useEffect(() => {
     *     function updateOpacity() {
     *       const maxXY = Math.max(x.get(), y.get())
     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
     *       opacity.set(newOpacity)
     *     }
     *
     *     const unsubscribeX = x.on("change", updateOpacity)
     *     const unsubscribeY = y.on("change", updateOpacity)
     *
     *     return () => {
     *       unsubscribeX()
     *       unsubscribeY()
     *     }
     *   }, [])
     *
     *   return <motion.div style={{ x }} />
     * }
     * ```
     *
     * @param subscriber - A function that receives the latest value.
     * @returns A function that, when called, will cancel this subscription.
     *
     * @deprecated
     */onChange(t){process.env.NODE_ENV!=="production"&&T(false,'value.onChange(callback) is deprecated. Switch to value.on("change", callback).');return this.on("change",t)}on(t,e){this.events[t]||(this.events[t]=new A);const n=this.events[t].add(e);return t==="change"?()=>{n();D.read((()=>{this.events.change.getSize()||this.stop()}))}:n}clearListeners(){for(const t in this.events)this.events[t].clear()}attach(t,e){this.passiveEffect=t;this.stopPassiveEffect=e}
/**
     * Sets the state of the `MotionValue`.
     *
     * @remarks
     *
     * ```jsx
     * const x = useMotionValue(0)
     * x.set(10)
     * ```
     *
     * @param latest - Latest value to set.
     * @param render - Whether to notify render subscribers. Defaults to `true`
     *
     * @public
     */set(t){this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t)}setWithVelocity(t,e,n){this.set(e);this.prev=void 0;this.prevFrameValue=t;this.prevUpdatedAt=this.updatedAt-n}jump(t,e=true){this.updateAndNotify(t);this.prev=t;this.prevUpdatedAt=this.prevFrameValue=void 0;e&&this.stop();this.stopPassiveEffect&&this.stopPassiveEffect()}dirty(){this.events.change?.notify(this.current)}addDependent(t){this.dependents||(this.dependents=new Set);this.dependents.add(t)}removeDependent(t){this.dependents&&this.dependents.delete(t)}
/**
     * Returns the latest state of `MotionValue`
     *
     * @returns - The latest state of `MotionValue`
     *
     * @public
     */get(){us.current&&us.current.push(this);return this.current}getPrevious(){return this.prev}
/**
     * Returns the latest velocity of `MotionValue`
     *
     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
     *
     * @public
     */getVelocity(){const t=N.now();if(!this.canTrackVelocity||this.prevFrameValue===void 0||t-this.updatedAt>as)return 0;const e=Math.min(this.updatedAt-this.prevUpdatedAt,as);return o(parseFloat(this.current)-parseFloat(this.prevFrameValue),e)}
/**
     * Registers a new animation to control this `MotionValue`. Only one
     * animation can drive a `MotionValue` at one time.
     *
     * ```jsx
     * value.start()
     * ```
     *
     * @param animation - A function that starts the provided animation
     */start(t){this.stop();return new Promise((e=>{this.hasAnimated=true;this.animation=t(e);this.events.animationStart&&this.events.animationStart.notify()})).then((()=>{this.events.animationComplete&&this.events.animationComplete.notify();this.clearAnimation()}))}stop(){if(this.animation){this.animation.stop();this.events.animationCancel&&this.events.animationCancel.notify()}this.clearAnimation()}isAnimating(){return!!this.animation}clearAnimation(){delete this.animation}destroy(){this.dependents?.clear();this.events.destroy?.notify();this.clearListeners();this.stop();this.stopPassiveEffect&&this.stopPassiveEffect()}}function ls(t,e){return new MotionValue(t,e)}const hs={x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"};function ds(t){let e="";let n=true;for(let s=0;s<We.length;s++){const i=We[s];const r=t.latest[i];if(r===void 0)continue;let o=true;o=typeof r==="number"?r===(i.startsWith("scale")?1:0):parseFloat(r)===0;if(!o){n=false;const s=hs[i]||i;const r=t.latest[i];e+=`${s}(${r}) `}}return n?"none":e.trim()}const fs=new Set(["originX","originY","originZ"]);const ms=(t,e,n,s)=>{let i;let r;if(Ne.has(n)){if(!e.get("transform")){os(t)||e.get("transformBox")||ms(t,e,"transformBox",new MotionValue("fill-box"));e.set("transform",new MotionValue("none"),(()=>{t.style.transform=ds(e)}))}r=e.get("transform")}else if(fs.has(n)){e.get("transformOrigin")||e.set("transformOrigin",new MotionValue(""),(()=>{const n=e.latest.originX??"50%";const s=e.latest.originY??"50%";const i=e.latest.originZ??0;t.style.transformOrigin=`${n} ${s} ${i}`}));r=e.get("transformOrigin")}else i=Ze(n)?()=>{t.style.setProperty(n,e.latest[n])}:()=>{t.style[n]=e.latest[n]};return e.set(n,s,i,r)};const ps=Qn(es(ms));const gs=rt.transform;function ys(t,e,n,s){D.render((()=>t.setAttribute("pathLength","1")));if(n==="pathOffset")return e.set(n,s,(()=>t.setAttribute("stroke-dashoffset",gs(-e.latest[n]))));e.get("stroke-dasharray")||e.set("stroke-dasharray",new MotionValue("1 1"),(()=>{const{pathLength:n=1,pathSpacing:s}=e.latest;t.setAttribute("stroke-dasharray",`${gs(n)} ${gs(s??1-Number(n))}`)}));return e.set(n,s,void 0,e.get("stroke-dasharray"))}const vs=(t,e,n,s)=>{if(n.startsWith("path"))return ys(t,e,n,s);if(n.startsWith("attr"))return ss(t,e,bs(n),s);const i=n in t.style?ms:ss;return i(t,e,n,s)};const ws=Qn(es(vs));function bs(t){return t.replace(/^attr([A-Z])/,((t,e)=>e.toLowerCase()))}const{schedule:Ts,cancel:As}=P(queueMicrotask,false);const xs={x:false,y:false};function Ms(){return xs.x||xs.y}function ks(t){if(t==="x"||t==="y"){if(xs[t])return null;xs[t]=true;return()=>{xs[t]=false}}if(xs.x||xs.y)return null;xs.x=xs.y=true;return()=>{xs.x=xs.y=false}}function Ss(t,e){const n=Jn(t);const s=new AbortController;const i={passive:true,...e,signal:s.signal};const r=()=>s.abort();return[n,i,r]}function Es(t){return!(t.pointerType==="touch"||Ms())}function Ps(t,e,n={}){const[s,i,r]=Ss(t,n);const o=t=>{if(!Es(t))return;const{target:n}=t;const s=e(n,t);if(typeof s!=="function"||!n)return;const r=t=>{if(Es(t)){s(t);n.removeEventListener("pointerleave",r)}};n.addEventListener("pointerleave",r,i)};s.forEach((t=>{t.addEventListener("pointerenter",o,i)}));return r}
/**
 * Recursively traverse up the tree to check whether the provided child node
 * is the parent or a descendant of it.
 *
 * @param parent - Element to find
 * @param child - Element to test against parent
 */const Ds=(t,e)=>!!e&&(t===e||Ds(t,e.parentElement));const Rs=t=>t.pointerType==="mouse"?typeof t.button!=="number"||t.button<=0:t.isPrimary!==false;const Vs=new Set(["BUTTON","INPUT","SELECT","TEXTAREA","A"]);function Fs(t){return Vs.has(t.tagName)||t.tabIndex!==-1}const Os=new WeakSet;function Ws(t){return e=>{e.key==="Enter"&&t(e)}}function Ns(t,e){t.dispatchEvent(new PointerEvent("pointer"+e,{isPrimary:true,bubbles:true}))}const Ks=(t,e)=>{const n=t.currentTarget;if(!n)return;const s=Ws((()=>{if(Os.has(n))return;Ns(n,"down");const t=Ws((()=>{Ns(n,"up")}));const s=()=>Ns(n,"cancel");n.addEventListener("keyup",t,e);n.addEventListener("blur",s,e)}));n.addEventListener("keydown",s,e);n.addEventListener("blur",(()=>n.removeEventListener("keydown",s)),e)};function Cs(t){return Rs(t)&&!Ms()}function $s(t,e,n={}){const[s,i,r]=Ss(t,n);const o=t=>{const s=t.currentTarget;if(!Cs(t))return;Os.add(s);const r=e(s,t);const o=(t,e)=>{window.removeEventListener("pointerup",a);window.removeEventListener("pointercancel",c);Os.has(s)&&Os.delete(s);Cs(t)&&typeof r==="function"&&r(t,{success:e})};const a=t=>{o(t,s===window||s===document||n.useGlobalTarget||Ds(s,t.target))};const c=t=>{o(t,false)};window.addEventListener("pointerup",a,i);window.addEventListener("pointercancel",c,i)};s.forEach((t=>{const e=n.useGlobalTarget?window:t;e.addEventListener("pointerdown",o,i);if(os(t)){t.addEventListener("focus",(t=>Ks(t,i)));Fs(t)||t.hasAttribute("tabindex")||(t.tabIndex=0)}}));return r}function Ls(t,e){const n=window.getComputedStyle(t);return Ze(e)?n.getPropertyValue(e):n[e]}function Bs(t){return b(t)&&"ownerSVGElement"in t}const js=new WeakMap;let Ys;const Xs=(t,e,n)=>(s,i)=>i&&i[0]?i[0][t+"Size"]:Bs(s)&&"getBBox"in s?s.getBBox()[e]:s[n];const Is=Xs("inline","width","offsetWidth");const zs=Xs("block","height","offsetHeight");function Us({target:t,borderBoxSize:e}){js.get(t)?.forEach((n=>{n(t,{get width(){return Is(t,e)},get height(){return zs(t,e)}})}))}function qs(t){t.forEach(Us)}function Zs(){typeof ResizeObserver!=="undefined"&&(Ys=new ResizeObserver(qs))}function _s(t,e){Ys||Zs();const n=Jn(t);n.forEach((t=>{let n=js.get(t);if(!n){n=new Set;js.set(t,n)}n.add(e);Ys?.observe(t)}));return()=>{n.forEach((t=>{const n=js.get(t);n?.delete(e);n?.size||Ys?.unobserve(t)}))}}const Gs=new Set;let Hs;function Js(){Hs=()=>{const t={get width(){return window.innerWidth},get height(){return window.innerHeight}};Gs.forEach((e=>e(t)))};window.addEventListener("resize",Hs)}function Qs(t){Gs.add(t);Hs||Js();return()=>{Gs.delete(t);if(!Gs.size&&typeof Hs==="function"){window.removeEventListener("resize",Hs);Hs=void 0}}}function ti(t,e){return typeof t==="function"?Qs(t):_s(t,e)}function ei(t,e){let n;const s=()=>{const{currentTime:s}=e;const i=s===null?0:s.value;const r=i/100;n!==r&&t(r);n=r};D.preUpdate(s,true);return()=>R(s)}function ni(){const{value:t}=k;if(t!==null){t.frameloop.rate.push(V.delta);t.animations.mainThread.push(K.mainThread);t.animations.waapi.push(K.waapi);t.animations.layout.push(K.layout)}else R(ni)}function si(t){return t.reduce(((t,e)=>t+e),0)/t.length}function ii(t,e=si){return t.length===0?{min:0,max:0,avg:0}:{min:Math.min(...t),max:Math.max(...t),avg:e(t)}}const ri=t=>Math.round(1e3/t);function oi(){k.value=null;k.addProjectionMetrics=null}function ai(){const{value:t}=k;if(!t)throw new Error("Stats are not being measured");oi();R(ni);const e={frameloop:{setup:ii(t.frameloop.setup),rate:ii(t.frameloop.rate),read:ii(t.frameloop.read),resolveKeyframes:ii(t.frameloop.resolveKeyframes),preUpdate:ii(t.frameloop.preUpdate),update:ii(t.frameloop.update),preRender:ii(t.frameloop.preRender),render:ii(t.frameloop.render),postRender:ii(t.frameloop.postRender)},animations:{mainThread:ii(t.animations.mainThread),waapi:ii(t.animations.waapi),layout:ii(t.animations.layout)},layoutProjection:{nodes:ii(t.layoutProjection.nodes),calculatedTargetDeltas:ii(t.layoutProjection.calculatedTargetDeltas),calculatedProjections:ii(t.layoutProjection.calculatedProjections)}};const{rate:n}=e.frameloop;n.min=ri(n.min);n.max=ri(n.max);n.avg=ri(n.avg);[n.min,n.max]=[n.max,n.min];return e}function ci(){if(k.value){oi();throw new Error("Stats are already being measured")}const t=k;t.value={frameloop:{setup:[],rate:[],read:[],resolveKeyframes:[],preUpdate:[],update:[],preRender:[],render:[],postRender:[]},animations:{mainThread:[],waapi:[],layout:[]},layoutProjection:{nodes:[],calculatedTargetDeltas:[],calculatedProjections:[]}};t.addProjectionMetrics=e=>{const{layoutProjection:n}=t.value;n.nodes.push(e.nodes);n.calculatedTargetDeltas.push(e.calculatedTargetDeltas);n.calculatedProjections.push(e.calculatedProjections)};D.postRender(ni,true);return ai}function ui(t){return Bs(t)&&t.tagName==="svg"}function li(t,e){if(t==="first")return 0;{const n=e-1;return t==="last"?n:n/2}}function hi(t=.1,{startDelay:e=0,from:n=0,ease:s}={}){return(i,r)=>{const o=typeof n==="number"?n:li(n,r);const a=Math.abs(o-i);let c=t*a;if(s){const e=r*t;const n=d(s);c=n(c/e)*e}return e+c}}function di(...t){const e=!Array.isArray(t[0]);const n=e?0:-1;const s=t[0+n];const i=t[1+n];const r=t[2+n];const o=t[3+n];const a=ue(i,r,o);return e?a(s):a}function fi(t,e,n){const s=()=>e.set(n());const i=()=>D.preRender(s,false,true);const r=t.map((t=>t.on("change",i)));e.on("destroy",(()=>{r.forEach((t=>t()));R(s)}))}
/**
 * Create a `MotionValue` that transforms the output of other `MotionValue`s by
 * passing their latest values through a transform function.
 *
 * Whenever a `MotionValue` referred to in the provided function is updated,
 * it will be re-evaluated.
 *
 * ```jsx
 * const x = motionValue(0)
 * const y = transformValue(() => x.get() * 2) // double x
 * ```
 *
 * @param transformer - A transform function. This function must be pure with no side-effects or conditional statements.
 * @returns `MotionValue`
 *
 * @public
 */function mi(t){const e=[];us.current=e;const n=t();us.current=void 0;const s=ls(n);fi(e,s,t);return s}
/**
 * Create a `MotionValue` that maps the output of another `MotionValue` by
 * mapping it from one range of values into another.
 *
 * @remarks
 *
 * Given an input range of `[-200, -100, 100, 200]` and an output range of
 * `[0, 1, 1, 0]`, the returned `MotionValue` will:
 *
 * - When provided a value between `-200` and `-100`, will return a value between `0` and  `1`.
 * - When provided a value between `-100` and `100`, will return `1`.
 * - When provided a value between `100` and `200`, will return a value between `1` and  `0`
 *
 * The input range must be a linear series of numbers. The output range
 * can be any value type supported by Motion: numbers, colors, shadows, etc.
 *
 * Every value in the output range must be of the same type and in the same format.
 *
 * ```jsx
 * const x = motionValue(0)
 * const xRange = [-200, -100, 100, 200]
 * const opacityRange = [0, 1, 1, 0]
 * const opacity = mapValue(x, xRange, opacityRange)
 * ```
 *
 * @param inputValue - `MotionValue`
 * @param inputRange - A linear series of numbers (either all increasing or decreasing)
 * @param outputRange - A series of numbers, colors or strings. Must be the same length as `inputRange`.
 * @param options -
 *
 *  - clamp: boolean. Clamp values to within the given range. Defaults to `true`
 *  - ease: EasingFunction[]. Easing functions to use on the interpolations between each value in the input and output ranges. If provided as an array, the array must be one item shorter than the input and output ranges, as the easings apply to the transition between each.
 *
 * @returns `MotionValue`
 *
 * @public
 */function pi(t,e,n,s){const i=di(e,n,s);return mi((()=>i(t.get())))}const gi=t=>Boolean(t&&t.getVelocity)
/**
 * Create a `MotionValue` that animates to its latest value using a spring.
 * Can either be a value or track another `MotionValue`.
 *
 * ```jsx
 * const x = motionValue(0)
 * const y = transformValue(() => x.get() * 2) // double x
 * ```
 *
 * @param transformer - A transform function. This function must be pure with no side-effects or conditional statements.
 * @returns `MotionValue`
 *
 * @public
 */;function yi(t,e){const n=gi(t)?t.get():t;const s=ls(n);vi(s,t,e);return s}function vi(t,e,n){const s=t.get();let i=null;let r=s;let o;const a=typeof s==="string"?s.replace(/[\d.-]/g,""):void 0;const c=()=>{if(i){i.stop();i=null}};const u=()=>{c();i=new JSAnimation({keyframes:[bi(t.get()),bi(r)],velocity:t.getVelocity(),type:"spring",restDelta:.001,restSpeed:.01,...n,onUpdate:o})};t.attach(((t,e)=>{r=t;o=t=>e(wi(t,a));D.postRender(u)}),c);if(gi(e)){const n=e.on("change",(e=>t.set(wi(e,a))));const s=t.on("destroy",n);return()=>{n();s()}}return c}function wi(t,e){return e?t+e:t}function bi(t){return typeof t==="number"?t:parseFloat(t)}const Ti=[...Vn,lt,Mt];const Ai=t=>Ti.find(Rn(t));function xi(t){return t==="layout"?"group":t==="enter"||t==="new"?"new":t==="exit"||t==="old"?"old":"group"}let Mi={};let ki=null;const Si={set:(t,e)=>{Mi[t]=e},commit:()=>{if(!ki){ki=document.createElement("style");ki.id="motion-view"}let t="";for(const e in Mi){const n=Mi[e];t+=`${e} {\n`;for(const[e,s]of Object.entries(n))t+=`  ${e}: ${s};\n`;t+="}\n"}ki.textContent=t;document.head.appendChild(ki);Mi={}},remove:()=>{ki&&ki.parentElement&&ki.parentElement.removeChild(ki)}};function Ei(t){const e=t.match(/::view-transition-(old|new|group|image-pair)\((.*?)\)/);return e?{layer:e[2],type:e[1]}:null}function Pi(t){const{effect:e}=t;return!!e&&(e.target===document.documentElement&&e.pseudoElement?.startsWith("::view-transition"))}function Di(){return document.getAnimations().filter(Pi)}function Ri(t,e){return e.has(t)&&Object.keys(e.get(t)).length>0}const Vi=["layout","enter","exit","new","old"];function Fi(t){const{update:e,targets:n,options:s}=t;if(!document.startViewTransition)return new Promise((async t=>{await e();t(new GroupAnimation([]))}));Ri("root",n)||Si.set(":root",{"view-transition-name":"none"});Si.set("::view-transition-group(*), ::view-transition-old(*), ::view-transition-new(*)",{"animation-timing-function":"linear !important"});Si.commit();const i=document.startViewTransition((async()=>{await e()}));i.finished.finally((()=>{Si.remove()}));return new Promise((t=>{i.ready.then((()=>{const e=Di();const i=[];n.forEach(((t,e)=>{for(const n of Vi){if(!t[n])continue;const{keyframes:r,options:o}=t[n];for(let[t,c]of Object.entries(r)){if(!c)continue;const r={...En(s,t),...En(o,t)};const u=xi(n);if(t==="opacity"&&!Array.isArray(c)){const t=u==="new"?0:1;c=[t,c]}typeof r.delay==="function"&&(r.delay=r.delay(0,1));r.duration&&(r.duration=a(r.duration));r.delay&&(r.delay=a(r.delay));const l=new NativeAnimation({...r,element:document.documentElement,name:t,pseudoElement:`::view-transition-${u}(${e})`,keyframes:c});i.push(l)}}}));for(const t of e){if(t.playState==="finished")continue;const{effect:e}=t;if(!e||!(e instanceof KeyframeEffect))continue;const{pseudoElement:r}=e;if(!r)continue;const o=Ei(r);if(!o)continue;const c=n.get(o.layer);if(c)Oi(c,"enter")&&Oi(c,"exit")&&e.getKeyframes().some((t=>t.mixBlendMode))?i.push(new NativeAnimationWrapper(t)):t.cancel();else{const n=o.type==="group"?"layout":"";let r={...En(s,n)};r.duration&&(r.duration=a(r.duration));r=on(r);const c=nn(r.ease,r.duration);e.updateTiming({delay:a(r.delay??0),duration:r.duration,easing:c});i.push(new NativeAnimationWrapper(t))}}t(new GroupAnimation(i))}))}))}function Oi(t,e){return t?.[e]?.keyframes.opacity}let Wi=[];let Ni=null;function Ki(){Ni=null;const[t]=Wi;t&&Ci(t)}function Ci(t){x(Wi,t);Ni=t;Fi(t).then((e=>{t.notifyReady(e);e.finished.finally(Ki)}))}function $i(){for(let t=Wi.length-1;t>=0;t--){const e=Wi[t];const{interrupt:n}=e.options;if(n==="immediate"){const n=Wi.slice(0,t+1).map((t=>t.update));const s=Wi.slice(t+1);e.update=()=>{n.forEach((t=>t()))};Wi=[e,...s];break}}Ni&&Wi[0]?.options.interrupt!=="immediate"||Ki()}function Li(t){Wi.push(t);Ts.render($i)}class ViewTransitionBuilder{constructor(t,n={}){this.currentSubject="root";this.targets=new Map;this.notifyReady=e;this.readyPromise=new Promise((t=>{this.notifyReady=t}));this.update=t;this.options={interrupt:"wait",...n};Li(this)}get(t){this.currentSubject=t;return this}layout(t,e){this.updateTarget("layout",t,e);return this}new(t,e){this.updateTarget("new",t,e);return this}old(t,e){this.updateTarget("old",t,e);return this}enter(t,e){this.updateTarget("enter",t,e);return this}exit(t,e){this.updateTarget("exit",t,e);return this}crossfade(t){this.updateTarget("enter",{opacity:1},t);this.updateTarget("exit",{opacity:0},t);return this}updateTarget(t,e,n={}){const{currentSubject:s,targets:i}=this;i.has(s)||i.set(s,{});const r=i.get(s);r[t]={keyframes:e,options:n}}then(t,e){return this.readyPromise.then(t,e)}}function Bi(t,e={}){return new ViewTransitionBuilder(t,e)}
/**
 * @deprecated
 *
 * Import as `frame` instead.
 */const ji=D;
/**
 * @deprecated
 *
 * Use cancelFrame(callback) instead.
 */const Yi=M.reduce(((t,e)=>{t[e]=t=>R(t);return t}),{});export{AsyncMotionValueAnimation,DOMKeyframesResolver,GroupAnimation,GroupAnimationWithThen,JSAnimation,KeyframeResolver,MotionValue,NativeAnimation,NativeAnimationExtended,NativeAnimationWrapper,ViewTransitionBuilder,Gn as acceleratedValues,K as activeAnimations,ss as addAttrValue,ms as addStyleValue,X as alpha,wt as analyseComplexValue,be as animateValue,Bi as animateView,Tn as animationMapKey,on as applyGeneratorOptions,qn as applyPxDefaults,vi as attachSpring,is as attrEffect,Ut as calcGeneratorDuration,R as cancelFrame,As as cancelMicrotask,Yi as cancelSync,us as collectMotionValues,lt as color,Mt as complex,de as convertOffsetToTimes,qt as createGeneratorEasing,P as createRenderBatcher,tn as cubicBezierAsString,fe as defaultEasing,he as defaultOffset,Re as defaultTransformValue,jn as defaultValueTypes,st as degrees,Vn as dimensionValueTypes,le as fillOffset,Te as fillWildcards,Fn as findDimensionValueType,Ai as findValueType,qe as flushKeyframeResolvers,D as frame,V as frameData,F as frameSteps,It as generateLinearEasing,Xn as getAnimatableNone,An as getAnimationMap,Ls as getComputedStyle,Yn as getDefaultValueType,Ct as getMixer,li as getOriginIndex,ts as getValueAsType,En as getValueTransition,Sn as getVariableValue,Ei as getViewAnimationLayerInfo,Di as getViewAnimations,et as hex,Ps as hover,ut as hsla,St as hslaToRgba,ae as inertia,ue as interpolate,Wt as invisibleValues,$ as isCSSVariableName,B as isCSSVariableToken,Ms as isDragActive,xs as isDragging,rn as isGenerator,os as isHTMLElement,gi as isMotionValue,Ds as isNodeOrChild,Rs as isPrimaryPointer,Bs as isSVGElement,ui as isSVGSVGElement,Zn as isWaapiSupportedEasing,me as keyframes,mn as makeAnimationInstant,nn as mapEasingToNativeEasing,pi as mapValue,zt as maxGeneratorDuration,Ts as microtask,Yt as mix,$t as mixArray,Ot as mixColor,jt as mixComplex,Et as mixImmediate,Dt as mixLinearColor,Pt as mixNumber,Lt as mixObject,Nt as mixVisibility,ls as motionValue,Y as number,Bn as numberValueTypes,ei as observeTimeline,Mn as parseCSSVariable,Ve as parseValueFromTransform,it as percent,Pn as positionalKeys,$s as press,ct as progressPercentage,rs as propEffect,rt as px,Fe as readTransformValue,ci as recordStats,ti as resize,Jn as resolveElements,J as rgbUnit,Q as rgba,I as scale,ks as setDragLock,_e as setStyle,oe as spring,yi as springValue,hi as stagger,sn as startWaapiAnimation,k as statsBuffer,ps as styleEffect,en as supportedWaapiEasing,yn as supportsBrowserAnimation,He as supportsFlags,Qe as supportsLinearEasing,_n as supportsPartialKeyframes,Ge as supportsScrollTimeline,ws as svgEffect,ji as sync,Rn as testValueType,N as time,di as transform,We as transformPropOrder,Ne as transformProps,mi as transformValue,Ln as transformValueTypes,ot as vh,at as vw};

