#!/usr/bin/env bash
# 🚀 Modern Database Restore Script for Permoney
# Intelligent encrypted PostgreSQL backup restore with smart GPG handling

set -e
set -o pipefail

# Ensure proper TTY for GPG interaction
export GPG_TTY=$(tty)

# Modern color palette
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly BOLD='\033[1m'
readonly DIM='\033[2m'
readonly NC='\033[0m'

# Configuration with smart defaults
BACKUP_FILE="${1:-maybe_db_20251020_000001.dump.gpg}"
DB_NAME="${POSTGRES_DB:-permoney_development}"
DB_USER="${POSTGRES_USER:-postgres}"
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
DECRYPTED_FILE=""

# Modern output functions
print_banner() {
    echo -e "${PURPLE}${BOLD}"
    cat << "EOF"
╔══════════════════════════════════════════════════════════════╗
║                                                              ║
║              🚀 PERMONEY DATABASE RESTORE 🚀                 ║
║                   Modern & Intelligent                       ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
EOF
    echo -e "${NC}"
}

print_step() {
    echo -e "${CYAN}${BOLD}▶ $1${NC}"
}

print_success() {
    echo -e "${GREEN}✅ $1${NC}"
}

print_error() {
    echo -e "${RED}❌ ERROR: $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠️  $1${NC}"
}

print_info() {
    echo -e "${BLUE}ℹ️  $1${NC}"
}

print_progress() {
    echo -e "${PURPLE}⏳ $1${NC}"
}

print_dim() {
    echo -e "${DIM}   $1${NC}"
}

# Smart prerequisite checking
check_prerequisites() {
    print_step "Checking prerequisites"
    
    # Check backup file
    if [ ! -f "$BACKUP_FILE" ]; then
        print_error "Backup file not found: $BACKUP_FILE"
        echo ""
        print_info "Available backup files:"
        ls -lh *.dump.gpg 2>/dev/null | awk '{print "  " $9 " (" $5 ")"}' || echo "  No .dump.gpg files found"
        echo ""
        echo -e "${CYAN}Usage: $0 [backup_file.dump.gpg]${NC}"
        exit 1
    fi
    
    local file_size=$(ls -lh "$BACKUP_FILE" | awk '{print $5}')
    print_success "Backup file: $BACKUP_FILE ($file_size)"
    
    # Check GPG
    if ! command -v gpg &> /dev/null; then
        print_error "GPG not installed"
        print_info "Install with: brew install gnupg"
        exit 1
    fi
    print_success "GPG ready"
    
    # Check PostgreSQL
    if ! command -v psql &> /dev/null; then
        print_error "PostgreSQL client not installed"
        print_info "Install with: brew install postgresql"
        exit 1
    fi
    
    local pg_version=$(psql --version | awk '{print $3}')
    print_success "PostgreSQL $pg_version ready"
    
    # Check pg_restore
    if ! command -v pg_restore &> /dev/null; then
        print_error "pg_restore not found"
        exit 1
    fi
    print_success "pg_restore ready"
    
    echo ""
}

# Database connection with retry
check_database_connection() {
    print_step "Testing database connection"
    
    local max_retries=3
    local retry=0
    
    while [ $retry -lt $max_retries ]; do
        if PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c '\q' 2>/dev/null; then
            print_success "Connected to PostgreSQL"
            echo ""
            return 0
        fi
        
        retry=$((retry + 1))
        if [ $retry -lt $max_retries ]; then
            print_warning "Connection failed, retrying ($retry/$max_retries)..."
            
            # Try to start PostgreSQL on macOS
            if [[ "$OSTYPE" == "darwin"* ]]; then
                print_dim "Attempting to start PostgreSQL..."
                brew services start postgresql 2>/dev/null || true
                sleep 2
            fi
        fi
    done
    
    print_error "Cannot connect to database"
    echo ""
    print_info "Troubleshooting:"
    print_dim "brew services list | grep postgresql"
    print_dim "brew services start postgresql"
    print_dim "Check .env.local for correct credentials"
    exit 1
}

# Show configuration
show_restore_info() {
    print_step "Restore Configuration"
    echo ""
    echo -e "${BOLD}📁 Backup:${NC}"
    print_dim "File: ${CYAN}$BACKUP_FILE${NC}"
    print_dim "Size: ${CYAN}$(ls -lh "$BACKUP_FILE" | awk '{print $5}')${NC}"
    print_dim "Modified: ${CYAN}$(ls -l "$BACKUP_FILE" | awk '{print $6, $7, $8}')${NC}"
    echo ""
    echo -e "${BOLD}🎯 Target:${NC}"
    print_dim "Database: ${CYAN}$DB_NAME${NC}"
    print_dim "Host: ${CYAN}$DB_HOST:$DB_PORT${NC}"
    print_dim "User: ${CYAN}$DB_USER${NC}"
    echo ""
}

# Interactive confirmation
confirm_restore() {
    # Check if database exists
    local db_exists=false
    local table_count=0
    
    if PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw "$DB_NAME"; then
        db_exists=true
        table_count=$(PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c \
            "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | xargs || echo "0")
    fi
    
    print_warning "This will COMPLETELY REPLACE your database!"
    
    if [ "$db_exists" = true ]; then
        print_warning "Current database '$DB_NAME' has $table_count tables - ALL WILL BE DELETED!"
    else
        print_info "Database '$DB_NAME' does not exist (will be created)"
    fi
    
    echo ""
    echo -e "${BOLD}Continue with restore?${NC}"
    echo -e "  ${GREEN}y${NC} - Yes, restore database"
    echo -e "  ${RED}n${NC} - No, cancel"
    echo ""
    
    while true; do
        read -p "Choice [y/n]: " -n 1 -r choice
        echo ""
        
        case $choice in
            [Yy])
                echo ""
                print_success "Proceeding with restore"
                echo ""
                return 0
                ;;
            [Nn])
                echo ""
                print_info "Restore cancelled"
                exit 0
                ;;
            *)
                echo -e "${RED}Please enter y or n${NC}"
                ;;
        esac
    done
}

# Modern GPG decryption with multiple strategies
decrypt_backup() {
    print_step "Decrypting backup"
    
    DECRYPTED_FILE="${BACKUP_FILE%.gpg}"
    
    # Remove old decrypted file if exists
    rm -f "$DECRYPTED_FILE" 2>/dev/null || true
    
    echo ""
    print_info "GPG will prompt for passphrase"
    print_dim "Enter the passphrase when prompted..."
    echo ""
    
    # Strategy 1: Standard GPG with proper TTY (most reliable)
    if gpg --decrypt --output "$DECRYPTED_FILE" "$BACKUP_FILE" 2>&1; then
        if [ -f "$DECRYPTED_FILE" ] && [ -s "$DECRYPTED_FILE" ]; then
            echo ""
            print_success "Backup decrypted successfully"
            echo ""
            return 0
        fi
    fi
    
    # Strategy 2: Try with pinentry-mode loopback
    print_warning "Trying alternative decryption method..."
    rm -f "$DECRYPTED_FILE" 2>/dev/null || true
    
    if gpg --pinentry-mode loopback --decrypt --output "$DECRYPTED_FILE" "$BACKUP_FILE" 2>&1; then
        if [ -f "$DECRYPTED_FILE" ] && [ -s "$DECRYPTED_FILE" ]; then
            echo ""
            print_success "Backup decrypted successfully"
            echo ""
            return 0
        fi
    fi
    
    # Strategy 3: Manual passphrase entry
    print_warning "Trying manual passphrase entry..."
    rm -f "$DECRYPTED_FILE" 2>/dev/null || true
    
    echo ""
    read -s -p "Enter GPG passphrase manually: " passphrase
    echo ""
    
    if echo "$passphrase" | gpg --batch --yes --passphrase-fd 0 --decrypt --output "$DECRYPTED_FILE" "$BACKUP_FILE" 2>&1; then
        if [ -f "$DECRYPTED_FILE" ] && [ -s "$DECRYPTED_FILE" ]; then
            echo ""
            print_success "Backup decrypted successfully"
            echo ""
            return 0
        fi
    fi
    
    # All strategies failed
    print_error "Failed to decrypt backup"
    echo ""
    print_info "Troubleshooting:"
    print_dim "1. Verify GPG passphrase is correct"
    print_dim "2. Check GPG keys: gpg --list-secret-keys"
    print_dim "3. Ensure GPG agent is running: gpgconf --launch gpg-agent"
    print_dim "4. Try manual decrypt: gpg --decrypt $BACKUP_FILE"
    
    rm -f "$DECRYPTED_FILE" 2>/dev/null || true
    exit 1
}

# Database operations
manage_database() {
    print_step "Preparing database"
    
    # Terminate connections
    print_progress "Terminating active connections..."
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c \
        "SELECT pg_terminate_backend(pid) FROM pg_stat_activity WHERE datname = '$DB_NAME' AND pid <> pg_backend_pid();" \
        > /dev/null 2>&1 || true
    
    # Drop database
    print_progress "Dropping existing database..."
    PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c \
        "DROP DATABASE IF EXISTS $DB_NAME;" > /dev/null 2>&1 || true
    
    # Create database
    print_progress "Creating fresh database..."
    if PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d postgres -c \
        "CREATE DATABASE $DB_NAME;" > /dev/null 2>&1; then
        print_success "Database '$DB_NAME' ready"
        echo ""
    else
        print_error "Failed to create database"
        exit 1
    fi
}

# Restore with progress
restore_database() {
    print_step "Restoring database"
    
    local backup_size=$(ls -lh "$DECRYPTED_FILE" | awk '{print $5}')
    print_info "Restoring $backup_size of data (this may take several minutes)..."
    echo ""
    
    local log_file="/tmp/pg_restore_$$.log"
    
    print_progress "Restoration in progress..."
    
    if PGPASSWORD="$POSTGRES_PASSWORD" pg_restore \
        --host="$DB_HOST" \
        --port="$DB_PORT" \
        --username="$DB_USER" \
        --dbname="$DB_NAME" \
        --verbose \
        --no-owner \
        --no-acl \
        --jobs=4 \
        "$DECRYPTED_FILE" > "$log_file" 2>&1; then
        print_success "Database restored successfully"
    else
        # Check if errors are critical
        if grep -qi "error" "$log_file" | head -5; then
            print_warning "Restore completed with warnings (usually normal)"
        else
            print_success "Database restored successfully"
        fi
    fi
    
    rm -f "$log_file" 2>/dev/null || true
    echo ""
}

# Cleanup and verify
cleanup_and_verify() {
    print_step "Cleaning up and verifying"
    
    # Secure cleanup
    if [ -f "$DECRYPTED_FILE" ]; then
        print_progress "Removing temporary files..."
        shred -u "$DECRYPTED_FILE" 2>/dev/null || rm -f "$DECRYPTED_FILE"
        print_success "Cleanup complete"
    fi
    
    # Verify
    print_progress "Verifying database integrity..."
    local table_count=$(PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c \
        "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | xargs)
    
    if [ "$table_count" -gt 0 ]; then
        print_success "Verified: $table_count tables restored"
        echo ""
        
        print_info "Top tables by size:"
        PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c \
            "SELECT 
                tablename,
                pg_size_pretty(pg_total_relation_size('public.'||tablename)) AS size,
                n_live_tup as rows
             FROM pg_tables t
             LEFT JOIN pg_stat_user_tables s ON t.tablename = s.relname
             WHERE schemaname = 'public' 
             ORDER BY pg_total_relation_size('public.'||tablename) DESC 
             LIMIT 5;" 2>/dev/null || true
    else
        print_warning "Database appears empty"
    fi
    
    echo ""
}

# Run migrations
run_migrations() {
    if [ ! -f "bin/rails" ]; then
        return 0
    fi
    
    print_step "Running migrations"
    
    if bundle exec rails db:migrate:status 2>/dev/null | grep -q "down"; then
        print_progress "Applying pending migrations..."
        if bundle exec rails db:migrate 2>&1 | tail -5; then
            print_success "Migrations complete"
        else
            print_warning "Migrations completed with warnings"
        fi
    else
        print_success "No pending migrations"
    fi
    
    echo ""
}

# Completion summary
print_completion_summary() {
    echo ""
    print_banner
    echo -e "${GREEN}${BOLD}🎉 DATABASE RESTORE COMPLETED! 🎉${NC}"
    echo ""
    
    local table_count=$(PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -t -c \
        "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | xargs || echo "?")
    
    echo -e "${BOLD}📊 Summary:${NC}"
    print_dim "✅ Backup: ${CYAN}$BACKUP_FILE${NC}"
    print_dim "✅ Database: ${CYAN}$DB_NAME${NC}"
    print_dim "✅ Tables: ${CYAN}$table_count${NC}"
    echo ""
    
    echo -e "${BOLD}🚀 Next Steps:${NC}"
    print_dim "1. Start server: ${CYAN}bin/dev${NC}"
    print_dim "2. Open app: ${CYAN}http://localhost:3000${NC}"
    print_dim "3. Verify your data"
    echo ""
    
    echo -e "${BOLD}🔗 Quick Commands:${NC}"
    print_dim "Database console: ${CYAN}psql -h $DB_HOST -U $DB_USER -d $DB_NAME${NC}"
    print_dim "Rails console: ${CYAN}bin/rails console${NC}"
    echo ""
    
    print_success "Your Permoney database is ready! 🚀"
    echo ""
}

# Error handler
handle_error() {
    local exit_code=$?
    echo ""
    print_error "Restore failed (exit code: $exit_code)"
    
    # Cleanup on error
    if [ -n "$DECRYPTED_FILE" ] && [ -f "$DECRYPTED_FILE" ]; then
        print_info "Cleaning up..."
        rm -f "$DECRYPTED_FILE"
    fi
    
    echo ""
    print_info "Need help? Check PostgreSQL and GPG logs"
    exit $exit_code
}

# Main execution
main() {
    trap handle_error ERR
    
    print_banner
    
    # Load environment
    if [ -f .env.local ]; then
        print_dim "Loading environment from .env.local"
        set -a
        source <(grep -E '^[A-Z_]+=.*' .env.local | grep -v '^#')
        set +a
        echo ""
    fi
    
    # Execute restore
    check_prerequisites
    check_database_connection
    show_restore_info
    confirm_restore
    decrypt_backup
    manage_database
    restore_database
    cleanup_and_verify
    run_migrations
    print_completion_summary
}

# Run
main "$@"
